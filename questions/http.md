# 网络相关问题

Form [Front-end-Developer-Interview-Questions](https://github.com/h5bp/Front-end-Developer-Interview-Questions)

* 为什么传统上利用多个域名来提供网站资源会更有效？
* 请尽可能完整得描述从输入 URL 到整个网页加载完毕及显示在屏幕上的整个流程。
* Long-Polling、Websockets 和 Server-Sent Event 之间有什么区别？
* 请描述以下 request 和 response headers：
  * Diff. between Expires, Date, Age and If-Modified-...
  * Do Not Track
  * Cache-Control
  * Transfer-Encoding
  * ETag
  * X-Frame-Options
* 什么是 HTTP method？请罗列出你所知道的所有 HTTP method，并给出解释。
* 请解释 HTTP status 301 与 302 的区别？

Form [Front-end-Developer-Interview-Questions](https://github.com/h5bp/Front-end-Developer-Interview-Questions)
1. padding 不为4的倍数就会出现的空白间隙， 个人详情tab paddding
2. 输入URL到看见页面发生了什么
	- DNS 解析
	- 发起TCP 请求
	- 发起HTTP 请求
	- 服务器处理请求并返回HTTP报文
	- 浏览器渲染
	- 连接结束
	2.1 DNS解析
		- 输入 www.baidu.com， 解析域名， 翻译成IP地址的过程
		- 浏览器缓存： 浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）
		- 系统缓存： 再在host页面检查是否有缓存对应的IP地址
		- 路由器缓存：在路由器中检查缓存， 如果有使用同一个路由器的主机访问过就会有记录
		- ISP（互联网服务停供商）缓存： 运营商的缓存
		- 根域名服务器： .
		- 顶级域名服务器：  .com, .net, .gov等等的缓存
		- 主域名服务器： baidu.com
		- 域名服务器: www.baidu.com
		- 存在负载均衡， 每次响应都可能是不同的IP返回
	2.2 发起TCP请求
		2.2.1 三次握手
			- 客户端发送syn包(Seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认；
			- 服务器收到syn包，必须确认客户的SYN（ack=x+1），
			  同时自己也发送一个SYN包（Seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
			- 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
		2.2.2 三次握手的原因
			- 为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误
				> 失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。
				主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。
			- 两次握手， 上面说的这种清空就不行， 缺少第三步的客户端发送，服务端没有接收到ACK为 Y+1 的时候就会一直等待。
			- 四次握手没有增加成功率
		2.2.3 四次挥手
			- 终止等待：客户端发送一个 FIN=1， ACK=Z, Seq=X，用来关闭客户端到服务器的数据传送，也就是客户端告诉服务器：我已经不会再给你发请求了。
			- 关闭等待：发送一个 ACK=X+1， Seq=Z。客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。 客户端向服务器的方向就释放了
			- 最后确认：发送一个 FIN=1, ACK=X， SEQ=Y， 用来关闭服务器到客户端的数据传送
			- 时间等待：主动关闭方收到FIN后，发送一个ACK=Y, Seq=X给被动关闭方，确认序号为收到序号+1,注意此时TCP连接还没有释放，
				必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
				- 保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
				- 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。
		2.2.4 为什么建立连接是三次握手，关闭连接确是四次挥手呢？
				建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，**把ACK和SYN放在一个报文里发送给客户端**。
				而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，
				所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。
	2.3 发送HTTP请求
		> 发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口 请求报文由请求行，请求报头，请求正文组成。

		2.3.1 POST / GET 区别
			- GET在浏览器回退时是无害的，而POST会再次提交请求。
			- GET产生的URL地址可以被Bookmark，而POST不可以。
			- GET请求会被浏览器**主动cache**，而POST不会，除非手动设置。
			- GET请求**只能进行url编码**，而POST支持多种编码方式。
			- GET请求**参数**会被完整保留在浏览器**历史记录**里，而POST中的参数不会被保留。
			- GET请求在URL中传送的参数是有**长度限制**的，而POST么有。
			- 对参数的**数据类型**，GET只接受ASCII字符，而POST没有限制。
			- GET比POST更不安全，因为**参数直接暴露在URL上**，所以不能用来传递敏感信息。
			- GET参数通过**URL传递**，POST放在**Request body**中
			- **GET会产生一个TCP数据包，而POST会产生两个TCP数据包**。
				- 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
				- 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。
		2.3.2 请求报头
			- 请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。
		2.3.3 请求数据
			- 包含传递的数据
		2.3.4 HTTP 缓存
			- 缓存规则分为**强制缓存**和**协商缓存**
			- 
